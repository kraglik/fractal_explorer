#include "mandelbox.h"

const std::string distance_function_code =
        "#define COMPONENT_FOLD(x) ( (x>1) ? (2-x) : ((x<-1) ?(-2-x):x))\n"
        "\n"
        "inline float square(float x) { return x*x; }\n"
        "\n"
        "inline void fold_box(float3 *v) {\n"
        "    v->x = COMPONENT_FOLD(v->x);\n"
        "    v->y = COMPONENT_FOLD(v->y);\n"
        "    v->z = COMPONENT_FOLD(v->z);\n"
        "}\n"
        "\n"
        "inline void fold_sphere(float3 *v, float r2, float r_min_2, float r_fixed_2)\n"
        "{\n"
        "    if (r2 < r_min_2)\n"
        "        *v *= r_fixed_2 / r_min_2;\n"
        "    else\n"
        "    if (r2 < r_fixed_2)\n"
        "        *v *= r_fixed_2 / r2;\n"
        "}\n"
        "float fractal_distance(float3 point) {\n"
        "\n"
        "    float3 p = point;\n"
        "\n"
        "    float r_min_2 = square(0.5f);\n"
        "    float r_fixed_2 = 1.0f;\n"
        "    float escape = square(100.0f);\n"
        "    float d_factor = 1;\n"
        "    float r2 = -1;\n"
        "    float scale = 2.39128f;\n"
        "    float c1 = fabs(scale - 1.0f);\n"
        "    float c2 = native_powr(fabs(scale), 1 - 32);\n"
        "\n"
        "     for (int i = 0; i < 16; i++) {\n"
        "         fold_box(&p);\n"
        "         r2 = dot(p, p);\n"
        "         fold_sphere(&p, r2, r_min_2, r_fixed_2);\n"
        "         p *= scale;\n"
        "         p += point;\n"
        "         if (r2 < r_min_2)\n"
        "             d_factor *= (r_fixed_2 / r_min_2);\n"
        "         else if (r2<r_fixed_2)\n"
        "             d_factor *= (r_fixed_2 / r2);\n"
        "         d_factor = d_factor * fabs(scale) + 1.0;\n"
        "         if ( r2 > escape )\n"
        "             break;\n"
        "     }\n"
        "    r2 = native_sqrt(dot(p, p));\n"
        "    return (r2 - c1) / d_factor - c2;\n"
        "}\n";


const std::string orbit_function_code =
        "float3 orbit_trap(float3 point) {\n"
        "        \n"
        "    float3 color = {1e20f, 1e20f, 1e20f};\n"
        "    float3 new_color;\n"
        "    float3 orbit = {0, 0, 0};\n"
        "    float3 m = {1.0f, 1.0f, 1.0f};\n"
        "    \n"
        "    float3 p = point;\n"
        "\n"
        "    float r_min_2 = square(0.5f);\n"
        "    float r_fixed_2 = 1.0f;\n"
        "    float escape = square(100.0f);\n"
        "    float d_factor = 1;\n"
        "    float r2 = -1;\n"
        "    float scale = 2.39128f;\n"
        "\n"
        "    float c1 = fabs(scale - 1.0f);\n"
        "    float c2 = native_powr(fabs(scale), 1 - 16);\n"
        "\n"
        "     for (int i = 0; i < 8; i++) {\n"
        "         fold_box(&p);\n"
        "         r2 = dot(p, p);\n"
        "\n"
        "         fold_sphere(&p, r2, r_min_2, r_fixed_2);\n"
        "\n"
        "         p *= scale;\n"
        "         p += point;\n"
        "\n"
        "         if (r2 < r_min_2)\n"
        "             d_factor *= (r_fixed_2 / r_min_2);\n"
        "         else if (r2<r_fixed_2)\n"
        "             d_factor *= (r_fixed_2 / r2);\n"
        "\n"
        "         d_factor = d_factor * fabs(scale) + 1.0;\n"
        "\n"
        "         orbit = max(orbit, p * m);\n"
        "\n"
        "         if ( r2 > escape )\n"
        "             break;\n"
        "     }\n"
        "\n"
        "    r2 = native_sqrt(dot(p, p));\n"
        "\n"
        "    return orbit;\n"
        "\n"
        "}\n";


Mandelbox::Mandelbox()
        : Fractal(distance_function_code, orbit_function_code) {}