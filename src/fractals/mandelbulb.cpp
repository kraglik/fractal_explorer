#include "mandelbulb.h"


const std::string distance_function_code =
        "inline void pow_vec(float3 *v, float3 *result, float power) {\n"
        "    float ph = atan(v->y / v->x);\n"
        "    float th = acos(v->z / fast_length(*v));\n"
        "\n"
        "    result->x = native_sin(power * th) * native_cos(power * ph);\n"
        "    result->y = native_sin(power * th) * native_sin(power * ph);\n"
        "    result->z = native_cos(power * th);\n"
        "    \n"
        "    *result *= native_powr(fast_length(*v), power);\n"
        "}\n"
        "\n"
        "inline float2 iterate_z(float dr, float3 z, float3 c, float power, int limit) {\n"
        "    float2 pair = { 0.0f, dr };\n"
        "\n"
        "    for (int i = 0;; i++) {\n"
        "\n"
        "        float r = fast_length(z);\n"
        "        float3 zn;\n"
        "        pow_vec(&z, &zn, power);\n"
        "        \n"
        "        zn += c;\n"
        "\n"
        "        if (i > limit || r > 2.0f) {\n"
        "\n"
        "            pair.x = r;\n"
        "            pair.y = dr;\n"
        "\n"
        "            break;\n"
        "\n"
        "        } else {\n"
        "        \n"
        "            dr = native_powr(r, power - 1.0f) * power * dr + 1.0f;\n"
        "            z = zn;\n"
        "\n"
        "        }\n"
        "    }\n"
        "\n"
        "    return pair;\n"
        "}\n"
        "\n"
        "float fractal_distance(float3 point) {\n"
        "                      \n"
        "    float2 p = iterate_z(1.0f, point, point, 8.0f, 20);\n"
        "\n"
        "    return (0.5f * native_log(p.x) * p.x) / p.y;\n"
        "}\n";

const std::string orbit_function_code =
        "float3 orbit_trap(float3 point) {\n"
        "                 \n"
        "   float3 z = point, c = point;\n"
        "   float dr = 1.0f;\n"
        "   float power = 8.0f;\n"
        "   int limit = 20;\n"
        "\n"
        "   float3 color = {1e20f, 1e20f, 1e20f};\n"
        "   float3 new_color;\n"
        "   float3 orbit = {0, 0, 0};\n"
        "   float3 m = {10.0f, 20.0f, 1.0f};\n"
        "   m = normalize(m);\n"
        "\n"
        "   float2 pair = { 0.0f, dr };\n"
        "        \n"
        "   for (int i = 0;; i++) {\n"
        "        \n"
        "       float r = fast_length(z);\n"
        "       float3 zn;\n"
        "       pow_vec(&z, &zn, power);\n"
        "   \n"
        "       zn += c;                \n"
        "        \n"
        "       if (i > 8 || r > 2.0f) {\n"
        "        \n"
        "           pair.x = r;\n"
        "           pair.y = dr;\n"
        "        \n"
        "           break;\n"
        "        \n"
        "       } else {\n"
        "                \n"
        "           dr = native_powr(r, power - 1.0f) * power * dr + 1.0f;\n"
        "           z = zn;\n"
        "                    \n"
        "           orbit = max(orbit, z * m);        \n"
        "       }\n"
        "   }\n"
        "\n"
        "   return orbit;\n"
        "\n"
        "}\n";

Mandelbulb::Mandelbulb()
        : Fractal(distance_function_code, orbit_function_code) {}